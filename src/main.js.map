{
  "version": 3,
  "sources": ["../node_modules/@ffmpeg/util/dist/esm/errors.js", "../node_modules/@ffmpeg/util/dist/esm/const.js", "../node_modules/@ffmpeg/util/dist/esm/index.js", "main.ts"],
  "sourcesContent": ["export const ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\nexport const ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n", "export const HeaderContentLength = \"Content-Length\";\n", "import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD, } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async (file) => {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = await (await fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = await (await fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = await readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async (url) => new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    const eventHandler = () => {\n        script.removeEventListener(\"load\", eventHandler);\n        resolve();\n    };\n    script.src = url;\n    script.type = \"text/javascript\";\n    script.addEventListener(\"load\", eventHandler);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n    const resp = await fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n        const reader = resp.body?.getReader();\n        if (!reader)\n            throw ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = await reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = await resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n    const buf = progress\n        ? await downloadWithProgress(url, cb)\n        : await (await fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n};\n", "import { fetchFile } from \"@ffmpeg/util\";\nimport { WorkerCommand, WorkerMessage } from \"./core-mt/worker\";\n\nconst worker = new Worker(\"./core-mt/worker.js\");\n\nconst fileInput = document.getElementById(\"fileInput\") as HTMLInputElement;\nconst trimButton = document.getElementById(\"trimButton\") as HTMLButtonElement;\nconst videoOutput = document.getElementById(\"videoOutput\") as HTMLVideoElement;\nconst progressBar = document.getElementById(\"progress\") as HTMLDivElement;\nconst timeRemainingDisplay = document.getElementById(\n  \"timeRemaining\"\n) as HTMLDivElement;\n\nfunction sendWorkerCommand<T = any>(\n  command: WorkerCommand,\n  args: any[] = []\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    worker.postMessage({ command, args } as WorkerMessage);\n    worker.onmessage = (event) => {\n      if (event.data.status === \"error\") {\n        reject(event.data.message);\n      } else if (event.data.status === \"progress\") {\n        const { percent, estimatedRemainingTime } = event.data;\n        progressBar.style.width = `${percent}%`;\n        timeRemainingDisplay.innerText = `Estimated Time Left: ${estimatedRemainingTime}s`;\n      } else {\n        resolve(event.data.result);\n      }\n    };\n  });\n}\n\nasync function loadFFmpeg() {\n  try {\n    console.log(\"Loading FFmpeg...\");\n    await sendWorkerCommand(\"load\");\n    console.log(\"FFmpeg loaded.\");\n  } catch (error) {\n    console.error(\"Error loading FFmpeg:\", error);\n  }\n}\n\nasync function trimVideo(file: File, startTime: string, endTime: string) {\n  console.log(\"Sending video trimming command to worker...\");\n\n  const inputFileData = await fetchFile(file);\n  const duration = (parseInt(endTime) - parseInt(startTime)).toString();\n  const args = [\n    \"-i\",\n    \"input.mp4\",\n    \"-ss\",\n    startTime,\n    \"-t\",\n    duration,\n    \"output.mp4\",\n  ];\n\n  console.log(\"Writing file to FFmpeg...\");\n  await sendWorkerCommand<void>(\"writeFile\", [\"input.mp4\", inputFileData]);\n\n  console.log(\"Running FFmpeg...\");\n  await sendWorkerCommand<void>(\"run\", args);\n\n  console.log(\"Reading output file from FFmpeg...\");\n  const output = await sendWorkerCommand<Uint8Array>(\"readFile\", [\n    \"output.mp4\",\n  ]);\n\n  const videoBlob = new Blob([new Uint8Array(output)], { type: \"video/mp4\" });\n\n  return URL.createObjectURL(videoBlob);\n}\ntrimButton.addEventListener(\"click\", async () => {\n  if (!fileInput.files || fileInput.files.length === 0) {\n    alert(\"Please select a video file.\");\n    return;\n  }\n\n  console.log(\"Starting trimming process...\");\n\n  const start = (document.getElementById(\"start\") as HTMLInputElement).value;\n  const end = (document.getElementById(\"end\") as HTMLInputElement).value;\n\n  try {\n    const trimmedVideoUrl = await trimVideo(fileInput.files[0], start, end);\n    videoOutput.src = trimmedVideoUrl;\n  } catch (error) {\n    console.error(\"Error during video trimming:\", error);\n  }\n});\n\nloadFFmpeg().catch(console.error);\n"],
  "mappings": "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",
  "names": ["ERROR_RESPONSE_BODY_READER", "ERROR_INCOMPLETED_DOWNLOAD", "init_errors", "__esmMin", "init_const", "__esmMin", "readFromBlobOrFile", "fetchFile", "init_esm", "__esmMin", "init_errors", "init_const", "blob", "resolve", "reject", "fileReader", "result", "event", "_a", "_b", "file", "__async", "data", "c", "require_main", "__commonJSMin", "exports", "init_esm", "worker", "fileInput", "trimButton", "videoOutput", "progressBar", "timeRemainingDisplay", "sendWorkerCommand", "command", "args", "resolve", "reject", "event", "percent", "estimatedRemainingTime", "loadFFmpeg", "__async", "error", "trimVideo", "file", "startTime", "endTime", "inputFileData", "fetchFile", "duration", "output", "videoBlob", "start", "end", "trimmedVideoUrl"]
}
